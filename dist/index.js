import{existsSync as X,mkdirSync as G,writeFileSync as O,readFileSync as x}from"fs";import{join as A,resolve as M}from"path";import{spawn as S}from"child_process";import{createHash as v}from"crypto";import{generate as D}from"orval";var k=new Map,u=(z)=>z,d=(z,T)=>({name:"openapi",action:`uv run --no-sync apx openapi ${z} ${T}`}),p=({input:z,output:T})=>({name:"orval",action:async()=>{if(!X(z)){console.warn(`[apx] OpenAPI spec not found at ${z}, skipping Orval generation`);return}let W=x(z,"utf-8"),Q=v("sha256").update(W).digest("hex");if(k.get(z)===Q){console.log("[apx] OpenAPI spec unchanged, skipping Orval generation");return}await D({input:z,output:T}),k.set(z,Q)}});function P(z={}){let{steps:T=[],ignore:W=[]}=z,Q,J=null,B=!1,Y=[],V=!1,N=[];function C(b){return new Promise((E,U)=>{if(B){console.log(`[apx] Skipping command (stopping): ${b}`),E();return}console.log(`[apx] Executing: ${b}`);let w=b.split(/\s+/),H=w[0],y=w.slice(1),F=process.env.APX_PIPE_OUTPUT==="1",q=S(H,y,{stdio:F?"pipe":"inherit",shell:!0,detached:!1});if(F&&q.stdout&&q.stderr)q.stdout.on("data",(L)=>{process.stdout.write(L)}),q.stderr.on("data",(L)=>{process.stderr.write(L)});if(N.push(q),q.on("error",(L)=>{console.error("[apx] Process error:",L),U(L)}),q.on("exit",(L,I)=>{if(N=N.filter((f)=>f.pid!==q.pid),I)console.log(`[apx] Process ${q.pid} exited with signal: ${I}`),E();else if(L!==0)console.error(`[apx] Process ${q.pid} exited with code: ${L}`),U(Error(`Command failed with exit code ${L}`));else E()}),B&&q.pid)console.log(`[apx] Killing process ${q.pid} (stopping)`),Z(q)})}function Z(b){if(!b.pid)return;try{if(process.platform!=="win32")process.kill(-b.pid,"SIGTERM"),console.log(`[apx] Sent SIGTERM to process group -${b.pid}`);else b.kill("SIGTERM"),console.log(`[apx] Sent SIGTERM to process ${b.pid}`)}catch(E){console.error(`[apx] Error killing process ${b.pid}:`,E);try{b.kill("SIGKILL")}catch(U){}}}async function R(b){if(B){console.log("[apx] Skipping action (stopping)");return}if(K(),typeof b==="string")await C(b);else{if(B)return;await b()}K()}async function $(){if(B){console.log("[apx] Skipping steps (stopping)");return}if(V){console.log("[apx] Steps already running, skipping...");return}console.log(`[apx] Running ${T.length} step(s)...`),V=!0;try{for(let b of T){if(B){console.log("[apx] Stopping during step execution");break}let E=Date.now();try{console.log(`[apx] ${b.name} ⏳`),await R(b.action),console.log(`[apx] ${b.name} ✓ (${Date.now()-E} ms)`)}catch(U){throw console.error(`[apx] ${b.name} ✗`,U),U}}console.log("[apx] All steps completed")}finally{V=!1}}function K(){if(!Q){console.error("[apx] outDir is not set");return}try{if(!X(Q))G(Q,{recursive:!0});let b=A(Q,".gitignore");if(!X(b))O(b,`*
`)}catch(b){console.error("[apx] failed to ensure output directory:",b)}}function _(){if(B)return;if(console.log(`[apx] Stopping... (${N.length} child processes)`),B=!0,J)clearTimeout(J),J=null;if(N.length>0)console.log(`[apx] Killing ${N.length} child process(es)...`),N.forEach((b)=>{if(b.pid)Z(b)}),N=[];console.log("[apx] Stopped")}function j(){B=!1,J=null,V=!1,N=[]}return{name:"apx",apply:()=>!0,configResolved(b){Q=M(b.root,b.build.outDir),Y=W.map((E)=>M(process.cwd(),E)),j(),K()},configureServer(b){b.httpServer?.once("close",()=>{console.log("[apx] Server closing, stopping plugin..."),_()}),K()},async buildStart(){if(K(),T.length>0)await $()},handleHotUpdate(b){if(K(),B){console.log("[apx] HMR update ignored (stopping)");return}if(Y.some((E)=>b.file.includes(E)))return;if(console.log(`[apx] HMR update detected: ${b.file}`),J)clearTimeout(J);J=setTimeout(async()=>{if(J=null,B)return;K(),await $(),K()},100),J.unref()},writeBundle(){K()},closeBundle(){K(),_()}}}var n=P;export{n as default,P as apx,u as Step,p as Orval,d as OpenAPI};

//# debugId=BC8F56B36798505F64756E2164756E21
//# sourceMappingURL=index.js.map
