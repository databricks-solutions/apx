import{existsSync as X,mkdirSync as f,writeFileSync as G,readFileSync as O}from"fs";import{join as x,resolve as I}from"path";import{spawn as A}from"child_process";import{createHash as S}from"crypto";import{generate as v}from"orval";var M=new Map,d=(q)=>q,l=(q,Q)=>({name:"openapi",action:`uv run --no-sync apx openapi ${q} ${Q}`}),u=({input:q,output:Q})=>({name:"orval",action:async()=>{if(!X(q)){console.warn(`[apx] OpenAPI spec not found at ${q}, skipping Orval generation`);return}let W=O(q,"utf-8"),N=S("sha256").update(W).digest("hex");if(M.get(q)===N){console.log("[apx] OpenAPI spec unchanged, skipping Orval generation");return}await v({input:q,output:Q}),M.set(q,N)}});function P(q={}){let{steps:Q=[],ignore:W=[]}=q,N,E=null,z=!1,Y=[],V=!1,K=[];function k(b){return new Promise((B,T)=>{if(z){console.log(`[apx] Skipping command (stopping): ${b}`),B();return}console.log(`[apx] Executing: ${b}`);let w=b.split(/\s+/),j=w[0],H=w.slice(1),L=A(j,H,{stdio:"inherit",shell:!0,detached:!1});if(K.push(L),L.on("error",(U)=>{console.error("[apx] Process error:",U),T(U)}),L.on("exit",(U,F)=>{if(K=K.filter((y)=>y.pid!==L.pid),F)console.log(`[apx] Process ${L.pid} exited with signal: ${F}`),B();else if(U!==0)console.error(`[apx] Process ${L.pid} exited with code: ${U}`),T(Error(`Command failed with exit code ${U}`));else B()}),z&&L.pid)console.log(`[apx] Killing process ${L.pid} (stopping)`),Z(L)})}function Z(b){if(!b.pid)return;try{if(process.platform!=="win32")process.kill(-b.pid,"SIGTERM"),console.log(`[apx] Sent SIGTERM to process group -${b.pid}`);else b.kill("SIGTERM"),console.log(`[apx] Sent SIGTERM to process ${b.pid}`)}catch(B){console.error(`[apx] Error killing process ${b.pid}:`,B);try{b.kill("SIGKILL")}catch(T){}}}async function C(b){if(z){console.log("[apx] Skipping action (stopping)");return}if(J(),typeof b==="string")await k(b);else{if(z)return;await b()}J()}async function $(){if(z){console.log("[apx] Skipping steps (stopping)");return}if(V){console.log("[apx] Steps already running, skipping...");return}console.log(`[apx] Running ${Q.length} step(s)...`),V=!0;try{for(let b of Q){if(z){console.log("[apx] Stopping during step execution");break}let B=Date.now();try{console.log(`[apx] ${b.name} ⏳`),await C(b.action),console.log(`[apx] ${b.name} ✓ (${Date.now()-B} ms)`)}catch(T){throw console.error(`[apx] ${b.name} ✗`,T),T}}console.log("[apx] All steps completed")}finally{V=!1}}function J(){if(!N){console.error("[apx] outDir is not set");return}try{if(!X(N))f(N,{recursive:!0});let b=x(N,".gitignore");if(!X(b))G(b,`*
`)}catch(b){console.error("[apx] failed to ensure output directory:",b)}}function _(){if(z)return;if(console.log(`[apx] Stopping... (${K.length} child processes)`),z=!0,E)clearTimeout(E),E=null;if(K.length>0)console.log(`[apx] Killing ${K.length} child process(es)...`),K.forEach((b)=>{if(b.pid)Z(b)}),K=[];console.log("[apx] Stopped")}function R(){z=!1,E=null,V=!1,K=[]}return{name:"apx",apply:()=>!0,configResolved(b){N=I(b.root,b.build.outDir),Y=W.map((B)=>I(process.cwd(),B)),R(),J()},configureServer(b){b.httpServer?.once("close",()=>{console.log("[apx] Server closing, stopping plugin..."),_()}),J()},async buildStart(){if(J(),Q.length>0)await $()},handleHotUpdate(b){if(J(),z){console.log("[apx] HMR update ignored (stopping)");return}if(Y.some((B)=>b.file.includes(B)))return;if(console.log(`[apx] HMR update detected: ${b.file}`),E)clearTimeout(E);E=setTimeout(async()=>{if(E=null,z)return;J(),await $(),J()},100),E.unref()},writeBundle(){J()},closeBundle(){J(),_()}}}var c=P;export{c as default,P as apx,d as Step,u as Orval,l as OpenAPI};

//# debugId=A884FACDB01DC86864756E2164756E21
//# sourceMappingURL=index.js.map
